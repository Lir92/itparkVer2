package lesson27;

public class Lecture27SpringFrameworkLecture {
    /*
    Конфигурации Spring:
        XML - классическая конфигурация для фреймворка.
            Плюсы: много документации.
            Минусы: старый подход, который редко где используется.

        Java-based
            Плюсы: можно решать некоторые проблемы в рантайме (во время работы программы)
                   независит от Spring.
            Минусы: все бины находятся в одном классе.
                    из-за того, что все бины находятся в одном классе, сложно сопровождать такой код.

        Annotation based: создание бинов при помощи аннотаций, которые навешиваются на класс или метод.
            Плюсы: отдельные классы представляют отдельные бины со своей логикой.
            Минусы: могут встречаться бины с одинаковым именем, который нужно определять, как будут работаться.


=================================================== Property-файл ======================================================
    Для работы с properties файлами можно использовать аннотации:
        @PropertySource("classpath:имя файла в ресурсах") - здесь указывается файл или путь к файлу с данными о подключении к бд
        @Bean(destroyMethod = "close") - определяем, что данный метод является бином и в скобках указываем метод закрытия,
    что бы завершить соединение.
        @Value("${jdbc.url}") - аннотация, которая получает свойства из загруженного файла
            Аннотацию @Value можно использовать не только на методе, но и на полях.
         ** ! ВАЖНО ! Если поле является статичным, то аннотация @Value не отработает. **
        В случае, если необходимо сделать аннотацию на статичном поле, то можно либо воспользоваться сеттером, либо
        использовать аннотацию @PostConstruct.


========================================================= SpEL =========================================================

    SpEL часто используется, как плейсхолдер в аннотации @Value (${} <- плейсхолдер)
    SpEL - достаточно не безопасная вещь, так как после запуска, последствия его действий не обратимы.

    В качестве SpEL выражения может выступать не только плейсхолдер, но и целые выражения, н-р:
        @Value("#(T(java.lang.Math).random() * 100.00)") - данное Спел выражение вернет случайное число от 0 до 100.
        private double random;

    Используя SpEL, стоит избегать передавать в него какую-то логику, так как это может отработать не так, как ожидаешь.

================================== Области действия бинов (Bean scopes) ================================================

 == Singleton - создаётся один раз на всё приложение. В зависимости подставляется один объект.
    Синглтон можно создать при помощи отдельного класса, в котором создаётся поле public Singleton INSTANCE и затем создаётся
    его конструктор с модификатором Private, где в INSTANCE присваевается значение new Singleton.
    Данный способ создания синглтонов - плохая практика, лучше всего для этого использовать перечисления или полагаться на Спринг,
    который сам создаст его по умолчанию.

 == Prototype - объект не создаётся пока не становится зависимостью другого бина. В каждый бин инжекстится свой экземпляр.
    ! ВАЖНО ! Prototype не помогает при проблемы с thread safety.

 == Request - бин создаётся на каждый web-запрос и в каждом запросе он свой.

 == Session - тоже самое, что и Request, только в рамках Servlet HTTP-сессии.

    По стандарту, Спринг не создаёт много отдельных объектов.

    Для того, что бы при помощи Спринга и бинов создавать разные методы, используется аннотация @Scope
    @Scope - навешивается, как на отдельные классы в которых создаются бины, так и на конфигурации.

=============================================== Жизненный цикл бинов ===================================================

    TODO: почитать про жизненный цикл бинов

============================================ Шаблоны проектирования ====================================================

 == GRASP - General Responsibility Assignment Software Patterns - шаблоны проектирования для решения общих задач по
        назначению обязанностей классам и объектам.

    При проектировании программы необходимо ответить себе на селдующие вопросы, которые помогает решить GRASP:
    Кто:
  - Информационный эксперт

  - Создатель - кто должен создавать определённые объекты?

  - Низкая связанность - это:
                            минимальная зависимость одного класса от другого;
                            возможность понять назначение класса без изучения других классов;
                            высокая степень повторного использования подсистем.

    При НС необходимо обходить прямое использование полей другого класса.

    НС полезна при изменении структуры и расширении программы. Изменения в одних классах не сильно влияют на другие классы,
    где они использованы.

    Лучше использовать Интерфейсы, чем наследование классов, так как наследование повышает связанность.

  - Высокое зацепление - данный шаблон необходим, что бы сохранить максимальную связь между обязанностями класса и его
        назначением
    При назначении обязанностей класс всегда должен оставаться целостным с точки зрения его назначения.

  - Контроллер - предназначен для отделения выполнения операций событий, приходящих от пользователя, бизнесс-логики приложения.
    Для этого выделяется отдельный класс, называемый "контроллером".

    Проблемы Контроллера - Раздутый контроллер:
        единственный класс контроллера обрабатывает слишком много событий;
        Контроллер сам выполняет все задачи для обработки события;
        Контроллер слишком много "знает" - имеет доступ к классам, к которым в идеале не должен доставать.

    Решение проблем:
        делать несколько классов-Контроллеров;
        Контроллер должен делегировать обязанности по выполнению другим объектам.

  - Полиморфизм - предназначен для упрощения алгоритмов выбора варианта поведения. Вместо использовани многочисленных ветвлений
        можно обрабатывать разные варианты поведения на основе типа.
    Альтернативные реализации поведения реализуются в разных классах, унаследованного от общего базового класса или интерфейса.

  - Чистая выдумка - это TODO: почитать
    Чистой выдумкой могут служить утилитарные классы, которые имеют один метод (н-р Connection или создание работника),
    который может использоваться во многих классах.

  - Посредник - это TODO: почитать

  - Защита от изменений - неизменная логика выносится в интерфейс, а те методы, которые могут подвергнуться изменениям,
        выносятся в классы, которые имплементируют интерфейс.
     */
}
