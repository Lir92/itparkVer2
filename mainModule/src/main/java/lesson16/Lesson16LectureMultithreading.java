package lesson16;

public class Lesson16LectureMultithreading {
    /*
=================================================== Spliterator ========================================================

    Spliterator - это split и iterator в одной функции, т.е. делит список и проходит по нему.

    Spliterator используется для оббегания структуры данных, которая внутри себя не поддерживает Stream-ы, н-р
    xml узлы.

================================================= Многопоточность ======================================================

    Все потоки расширяют (классы потоков) класс Thread.

    В многопоточности есть ГЛАВНЫЙ ПОТОК и ВТОРОСТЕПЕННЫЕ ПОТОКИ:
        * Главный поток запускает весь поток после чего начинают работать Второстепенные потоки.

    Многопоточность - используется при необходимости выполнения различных операций, н-р один метод что-то записывает,
        другой метод, из этого же файла читает данные, третий их обрабатывает или синхронизирует работу.

 ** Программа с многопоточностью завершается, когда заканчивают работу все НЕ ДЕМОН-ПОТОКИ.

    Многопоточность в java не имеет установленных приоритетов выполнения. Приоритет можно указать самостоятельно при
    помощи setPriority(от 1 MIN_PRIORITY до 10 MAX_PRIORITY), но 100% выполнение этого выставленного приоритета не
    гарантируется.

=== Существуют также ПОТОКИ ДЕМОНЫ -
    Потоки Демоны необходимы для задач, которые выполняются в фоне и выполнение которых никак не влияют на работу программы,
    н-р поток перемещает какие-то данные, во время работы программы. Это необходимо для того, что бы программа не
    дожидалась окончания перемещения данных, а завершит свою работу и это перемещение закончится уже при последующем запуске.

    При завершении работы основного потока, демон-потоки сразу же заканчивают свою работу, прерывая процессы.

    Приоритет у Демон-потока работает также, как и у обычных потоков.

========================================== Синхронизация многопоточности ===============================================

 ** Так как в многопоточности методы работают без какой-то фиксированной логики и один поток может быть перебит другим,
    то для оптимизации потоков используют метод synchronized.

    Synchronized - это метод для синхронизации потока. Он необходим, что бы при многопоточности выполнялся блок целиком,
    а не частично.

    Synchronized можно также использовать на методе. Если необходимо заблокировать метод / объект и не предоставилять
    возможность его использовать, то можно использовать Synchronized на методе / объекте.

    Так как Synchronized блокирует поле / объект / метод, который использует, то лучше всего использовать его точечно,
    как часть логики какого-либо метода, иначе, если использовать Synchronized на:
        * Статическом методе, то придётся делать блокировку всего класса его методы будут не доступны для других объектов
        на время работы;

================================== Жизненный цикл потока (программы) ===================================================

    У потока подразделяются следующие циклы (статусы):

    NEW - только что созданный поток, которы не находится в работе;
    RUNNABLE - запущенный, но не работающий поток;
    RUNNING - работающий поток;
    WAITING - поток, находящийся в режиме ожидания (ждёт какое-то время или каких-то операций)
    DEAD - конец жизни потока, завершение работы.
     */
}