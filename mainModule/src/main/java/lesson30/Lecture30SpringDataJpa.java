package lesson30;

public class Lecture30SpringDataJpa {
    /*
    DataSource - спринговое подобие Connection

    JdbcTemplate - основной класс данных, который используется при подключении к БД при использовании JDBC.

    JdbcTemplate может:
        выполнять SQL запросы;
        итерировать по результатам (ResultSet);
        ловить JDBC исключения.

    Для работы JdbcTemplate необходимо:
        DataSource;
        RowMapper;
        SQL запрос.

    JdbcTemplate - более потокобезопасный, чем, если бы тот же код был бы написан на чистой java.

    JdbcTemplate может быть сконфигурирован однажды и использоваться несколькими DAO.

    JdbcTemplate в Spring преобразует SQLException в runtime-исключение DataExcessException, который в свою очередь можно
    категоризировать


============================================= Аннотации @Entity & @Id ==================================================

    @Entity - обозначает для ORM-фреймворка класс, как сущность. Значит нужно считать и запомнить его метаданные, сгенерировать
    запрос и т.д.

    @Id - аннотация, которой помечают поле идентификатора. Данное поле считается ключевым и без него (или @EmbeddedId)
    ничего не заработает.

    @GeneratedValue - разметка сущности - указывает, что идентификатор должен генерироваться. Позволяет задать стратегию
    генерации и имя файла.

    Стратегии и генерации ключей:
        GenerationType.AUTO - автоматический выбор;
        GenerationType.IDENTITY - генерация на основе автоинкрементного поля таблицы;
        GenerationType.SEQUENCE - генерация на основе заданной последовательности (по умолчанию один на всех hibernate_sequence)
        GenerationType.TABLE - генерация на основе заданной таблицы со значениями ключевого поля (по умолчанию один на всех hibernate_sequence)

    В сумме стратегии генерации ключей делятся на 2 типа:
        1-й - ключи генерируются самой БД при помощи автоинкрементации;
        2-й - ключи генерируются при помощи фреймворка

    @Table - данная аннотация вешается над классом и задаёт имя таблицы на которую она навешивается. Также она позволяет
            указать название схемы, уникальных полей и задать индексы (большая часть настроек актуальна, только если схему БД генерирует
            ORM-провайдер)

    @Column - вешается над полем и задаёт имя поля, на которое будет отображаться имя класса, а также ограничения данного поля
             (большая часть настроек актуальна, только если схему БД генерирует ORM-провайдер).

=================================================== Liquibase ==========================================================
    Liquibase - даёт возможность писать скрипты, не привязываясь к определённой БД.

    todo: почитать про Liquibase

    Основные абстракции для манипуляций с БД: 1) EntityManager и EntityManagerFactory,
                                              2) Spring ORM. Позволяет использовать JPA репазитории.
    Операции EntityManager:
       - find - поиск и загрузка сущности. Минус - необходимо указывать какой-то первичный ключ (id) по которому будет производиться поиск
            Есть способ обхода поиска по первичному ключу.
       - persist - добавление сущности в БД. Также даёт возможность получения сущности
       - merge - обновление сущности в БД
       - remove - удаление сущности, не удаляет по ID.
       - createQuery - создание объекта запроса

  == Основные плюсы ORM (JPA):
        ORM позволяет позволяет оперировать ООП и бизнес-понятиями, поля вместо столбцов, объекты вместо таблиц;
        ORM позволяет обстрагироваться от диалекта SQL;
        Уменьшается количество кода для написания
        Совместно со Spring Boot и Spring Data даёт большие возможности для разработки.

  == Минусы ORM:
        важно понимать, как работает то, что находится "под капотом", так как реализация скрыта от программиста;
        "прожорлив" в производительности;
        нет нормального доступа к нативному SQL и всем возможностям БД.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ==== ORM или JDBC? ==== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     ORM:
     Если проект завязан на стандартных CRUDE операциях без большой нагрузке, стоит использовать ORM. В таком случае не
     придётся самому писать SQL запросы, всё это сделает SQL.

     JDBC:
     Если же система загружена и работа идёт с большими потоками данных, то стоит использовать JDBC или Spring Data JDBC.

     */
}
